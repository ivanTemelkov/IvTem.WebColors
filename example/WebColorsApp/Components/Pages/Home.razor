@page "/"
@using System.Collections.Immutable
@using IvTem.WebColors.Abstractions.Extensions
@using IvTem.WebColors.Abstractions.Feature.ColorService
@using IvTem.WebColors.Abstractions.Model
@using IvTem.WebColors.Abstractions.Utility
@using IvTem.WebColors.Feature.ColorService

<PageTitle>Computed Color</PageTitle>

<div style="display: flex; flex-direction: column; margin: 0.25em;">
    <div style="flex: 0 0 auto;padding: 0.5em 0;display: flex;flex-direction: row;align-items: center;">
        <div style="flex: 0 0 auto;">
            Background Color: 
        </div>
        <div style="flex: 1 1 auto;">
            <InputText Value="@InputColor" ValueChanged="@ColorValueChanged" ValueExpression="() => InputColor"/>    
        </div>
    </div>    
    <div style="flex: 0 0 auto; padding: 0.5em 0;">
        
        @foreach (var computedResult in LastComputedResults)
        {
            @if (computedResult.Failure is not null)
            {
                <div style="color: tomato; padding: 0.5em; border: 0.25em solid tomato; border-radius: 0.5em; margin-bottom: 0.25em;">
                    @computedResult.Failure
                </div>
            }
            else
            {
                var color = computedResult.Color.Stringify();
                var backgroundColor = computedResult.BackgroundColor.ToRgb().Stringify();
                // var backgroundColor = computedResult.BackgroundColor.ToHsl().Stringify();
        
                <div style="color: @color; background-color: @backgroundColor; border-radius: 0.5em; padding: 0.5em; margin-bottom: 0.25em; display: flex; flex-direction: row;">
                    <div style="flex: 1 1 auto;">
                        @backgroundColor
                    </div>
        
                </div>
            }
        }

        @* @if (ComputedColors.Length > 0) *@
        @* { *@
        @*     @for (var i = 0; i < ComputedColors.Length; i++) *@
        @*     { *@
        @*         var color = ComputedColors[i]; *@
        @*         <div @key="@color.ColorName" style="display: flex; flex-direction: row; background-color: @color.ColorName;"> *@
        @*             <div>@i</div> *@
        @*             <div>@color.ColorName</div> *@
        @*             <div style="=display: flex; flex-direction: column;"> *@
        @*                 <div>@color.Color</div> *@
        @*                 <div>@color.ComputedColor</div>     *@
        @*             </div> *@
        @*         </div> *@
        @*     }     *@
        @* } *@
        
    </div>    
</div>





@code {

    private static readonly IWebColor DarkColor = new RgbaColor(red: 0, green: 0, blue: 0);
    private static readonly IWebColor LightColor = new RgbaColor(red: 255, green: 255, blue: 255);

    [Inject] private ComputedColorService ComputedColorService { get; set; } = null!;

    private string? InputColor { get; set; } = "cyan";

    private List<(IWebColor Color, IWebColor BackgroundColor, string? Failure)> LastComputedResults { get; set; } = new();

    private ImmutableArray<(string ColorName, RgbaColor Color, RgbaColor ComputedColor)> ComputedColors { get; set; } = [];

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender == false)
            return;

        await ComputeColor(InputColor);

        ComputedColors = await InitializeColors();

        await InvokeAsync(StateHasChanged);
    }

    private async Task<ImmutableArray<(string ColorName, RgbaColor Color, RgbaColor ComputedColor)>> InitializeColors()
    {
        List<(string ColorName, RgbaColor Color, RgbaColor ComputedColor)> result = [];
        foreach (var colorName in ColorList.All.Keys)
        {
            var webColorResult = await ComputedColorService.GetColor(colorName);
            if (webColorResult is WebColorSuccess success && success.Color is RgbaColor rgbaColor)
            {
                var color = ColorList.All[colorName];
                if (color == rgbaColor)
                {
                    result.Add((colorName, color, rgbaColor));    
                }
            }
        }

        return [..result];
    }
    
    private async Task ComputeColor(string? inputColor)
    {
        string? failureReason = null;
        
        if (string.IsNullOrWhiteSpace(inputColor))
        {
            failureReason = "Cannot covert an empty string to Web Color!";
            LastComputedResults.Add((DarkColor, DarkColor, failureReason));
            await InvokeAsync(StateHasChanged);
            return;
        }
        
        var result = await ComputedColorService.GetColor(inputColor);

        IWebColor computedColor = DarkColor;
        switch (result)
        {
            case WebColorSuccess success:
                computedColor = success.Color;
                break;
            case WebColorFailure failure:
                failureReason = failure.Reason;
                break;
            default:
                failureReason = $"Unexpected {nameof(WebColorResult)} type: {result.GetType().Name}!";
                break;
        }

        var color = computedColor.IsLightColor()
            ? DarkColor
            : LightColor;

        LastComputedResults.Add((color, computedColor, failureReason));
        await InvokeAsync(StateHasChanged);
    }

    private Task ColorValueChanged(string? inputColor)
    {
        InputColor = inputColor;
        return ComputeColor(InputColor);
    }

}